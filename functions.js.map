{"version":3,"file":"functions.js","mappings":"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","sources":["webpack://excel-custom-functions/./src/functions/functions.ts"],"sourcesContent":["/* global clearInterval, console, CustomFunctions, setInterval */\n\ntype CharMap = { [key: string]: string };\n\nconst soraniToLatinMap: CharMap = {\n  ا: \"a\",\n  ە: \"e\",\n  ب: \"b\",\n  پ: \"p\",\n  ت: \"t\",\n  ج: \"c\",\n  چ: \"ç\",\n  ح: \"ẖ\",\n  خ: \"x\",\n  د: \"d\",\n  ر: \"r\",\n  ڕ: \"ṟ\",\n  ز: \"z\",\n  ژ: \"j\",\n  س: \"s\",\n  ش: \"ş\",\n  غ: \"x̱\",\n  ف: \"f\",\n  ڤ: \"v\",\n  ق: \"q\",\n  ک: \"k\",\n  گ: \"g\",\n  ل: \"l\",\n  ڵ: \"ḻ\",\n  م: \"m\",\n  ن: \"n\",\n  ه: \"h\",\n  و: \"u\",\n  ۆ: \"o\",\n  ی: \"î\",\n  ێ: \"ê\",\n  ع: \"'\",\n  ئ: \"\",\n  // Multi-character mappings\n  وو: \"û\",\n  یە: \"ye\",\n  یا: \"ya\",\n  دە: \"de\",\n  نە: \"ne\",\n  بە: \"be\",\n  لە: \"le\",\n  وا: \"wa\",\n  کە: \"ke\",\n  وە: \"we\",\n  تێ: \"tê\",\n  پێ: \"pê\",\n  بێ: \"bê\",\n  بوو: \"bû\",\n};\n\nconst latinToSoraniMap: CharMap = Object.fromEntries(\n  Object.entries(soraniToLatinMap).map(([sorani, latin]) => [latin, sorani])\n);\n\nfunction isConsonant(char: string): boolean {\n  return /[bcçdfghjklḻmnpqrṟsştvwxyzBCÇDFGHJKLḺMNPQRṞSŞTVWXYZبپتجچدرڕزژسشغفڤقکگلڵمنه]/.test(char);\n}\n\nfunction insertShortI(latinWord: string): string {\n  const vowels = \"aiouûêî\";\n  const consonants = \"bcçdfghjklḻmnpqrṟsştvwxyz\";\n  const validClusters = [\"br\", \"dr\", \"fr\", \"gr\", \"kr\", \"pr\", \"tr\", \"bl\", \"dl\", \"fl\", \"gl\", \"kl\", \"pl\"];\n\n  let result = \"\";\n  let i = 0;\n\n  while (i < latinWord.length) {\n    result += latinWord[i];\n\n    if (\n      i < latinWord.length - 1 &&\n      consonants.includes(latinWord[i].toLowerCase()) &&\n      consonants.includes(latinWord[i + 1].toLowerCase())\n    ) {\n      const prevChar = i > 0 ? latinWord[i - 1].toLowerCase() : \"\";\n      const nextChar = i + 2 < latinWord.length ? latinWord[i + 2].toLowerCase() : \"\";\n      const currentPair = latinWord.substr(i, 2).toLowerCase();\n\n      if ((!vowels.includes(prevChar) || !prevChar) && (!vowels.includes(nextChar) || !nextChar)) {\n        result += \"i\";\n      }\n    }\n    i++;\n  }\n\n  return result;\n}\n\n/**\n * Converts Sorani Kurdish text to Latin script.\n * @customfunction SORANI_TO_LATIN\n * @param text Sorani Kurdish text to convert\n * @returns The text converted to Latin script\n */\nexport function soraniToLatin(text: string): string {\n  let result = \"\";\n  const sentences = text.split(/([.!?]+)/);\n  for (let i = 0; i < sentences.length; i += 2) {\n    const sentence = sentences[i].trim();\n    if (sentence.length === 0) continue;\n\n    let sentenceResult = \"\";\n    const words = sentence.split(/\\s+/);\n    for (const word of words) {\n      let latinWord = \"\";\n      for (let j = 0; j < word.length; j++) {\n        let matched = false;\n        // Special handling for 'ئا' at the beginning of a word\n        if (j === 0 && word.startsWith(\"ئا\")) {\n          latinWord += \"a\";\n          j += 1; // Skip the next character as we've handled 'ئا'\n          matched = true;\n        }\n        if (j === 0 && word.startsWith(\"ئە\")) {\n          latinWord += \"e\";\n          j += 1; // Skip the next character as we've handled 'ئا'\n          matched = true;\n        }\n        if (j === 0 && word.startsWith(\"ئێ\")) {\n          latinWord += \"ê\";\n          j += 1; // Skip the next character as we've handled 'ئا'\n          matched = true;\n        }\n        if (j === 0 && word.startsWith(\"ئو\")) {\n          latinWord += \"u\";\n          j += 1; // Skip the next character as we've handled 'ئا'\n          matched = true;\n        } else {\n          // Check for multi-character mappings\n          for (let len = Math.min(4, word.length - j); len > 1; len--) {\n            const substr = word.substr(j, len);\n            if (substr in soraniToLatinMap) {\n              latinWord += soraniToLatinMap[substr];\n              j += len - 1;\n              matched = true;\n              break;\n            }\n          }\n        }\n        if (!matched) {\n          // Handle 'ی' at the beginning of a word\n          if (j === 0 && word[j] === \"ی\") {\n            latinWord += \"y\";\n          } else {\n            latinWord += soraniToLatinMap[word[j]] || word[j];\n          }\n        }\n      }\n\n      // Insert short 'i' between consonants\n      latinWord = insertShortI(latinWord);\n\n      sentenceResult += (sentenceResult ? \" \" : \"\") + latinWord;\n    }\n    result += (result ? \" \" : \"\") + sentenceResult.charAt(0).toUpperCase() + sentenceResult.slice(1);\n    if (i + 1 < sentences.length) {\n      result += sentences[i + 1]; // Add back the punctuation\n    }\n  }\n  return result;\n}\n\n/**\n * Converts Latin script to Sorani Kurdish text.\n * @customfunction LATIN_TO_SORANI\n * @param text Latin script text to convert\n * @returns The text converted to Sorani Kurdish\n */\nexport function latinToSorani(text: string): string {\n  let result = \"\";\n  const words = text.split(/\\s+/);\n  for (const word of words) {\n    let soraniWord = \"\";\n    for (let i = 0; i < word.length; i++) {\n      let matched = false;\n      // Special handling for 'a' at the beginning of a word\n      if (i === 0 && word[i].toLowerCase() === \"a\") {\n        soraniWord += \"ئا\";\n        matched = true;\n      } else if (word[i].toLowerCase() === \"y\") {\n        soraniWord += \"ی\";\n        matched = true;\n      } else if (i === 0 && word[i].toLowerCase() === \"u\" && word[i].toLowerCase().length > 1) {\n        soraniWord += \"ئو\";\n        matched = true;\n      } else if (i === 0 && word[i].toLowerCase() === \"e\") {\n        soraniWord += \"ئە\";\n        matched = true;\n      } else if (i === 0 && word[i].toLowerCase() === \"ê\") {\n        soraniWord += \"ئێ\";\n        matched = true;\n      } else if (word[i].toLowerCase() === \"w\") {\n        soraniWord += \"و\";\n        matched = true;\n      } else {\n        // Check for multi-character mappings first\n        for (let len = Math.min(4, word.length - i); len > 1; len--) {\n          const substr = word.substr(i, len).toLowerCase();\n          if (substr in latinToSoraniMap) {\n            soraniWord += latinToSoraniMap[substr];\n            i += len - 1;\n            matched = true;\n            break;\n          }\n        }\n      }\n      if (!matched) {\n        // Handle 'y' at the beginning of a word\n        if (i === 0 && word[i].toLowerCase() === \"y\") {\n          soraniWord += \"ی\";\n        } else if (\n          word[i].toLowerCase() === \"i\" &&\n          i > 0 &&\n          i < word.length - 1 &&\n          isConsonant(word[i - 1]) &&\n          isConsonant(word[i + 1])\n        ) {\n          // Skip short 'i' sound between consonants\n          continue;\n        } else {\n          soraniWord += latinToSoraniMap[word[i].toLowerCase()] || word[i];\n        }\n      }\n    }\n    result += (result ? \" \" : \"\") + soraniWord;\n  }\n  return result;\n}\n\n/**\n * Adds two numbers.\n * @customfunction ADD\n * @param first First number\n * @param second Second number\n * @returns The sum of the two numbers.\n */\nexport function add(first: number, second: number): number {\n  return first + second;\n}\n\n/**\n * Displays the current time once a second.\n * @customfunction\n * @param invocation Custom function handler\n */\nexport function clock(invocation: CustomFunctions.StreamingInvocation<string>): void {\n  const timer = setInterval(() => {\n    const time = currentTime();\n    invocation.setResult(time);\n  }, 1000);\n\n  invocation.onCanceled = () => {\n    clearInterval(timer);\n  };\n}\n\n/**\n * Returns the current time.\n * @returns String with the current time formatted for the current locale.\n */\nexport function currentTime(): string {\n  return new Date().toLocaleTimeString();\n}\n\n/**\n * Increments a value once a second.\n * @customfunction\n * @param incrementBy Amount to increment\n * @param invocation Custom function handler\n */\nexport function increment(incrementBy: number, invocation: CustomFunctions.StreamingInvocation<number>): void {\n  let result = 0;\n  const timer = setInterval(() => {\n    result += incrementBy;\n    invocation.setResult(result);\n  }, 1000);\n\n  invocation.onCanceled = () => {\n    clearInterval(timer);\n  };\n}\n\n/**\n * Writes a message to console.log().\n * @customfunction LOG\n * @param message String to write.\n * @returns String to write.\n */\nexport function logMessage(message: string): string {\n  console.log(message);\n  return message;\n}\n\nCustomFunctions.associate(\"SORANI_TO_LATIN\", soraniToLatin);\nCustomFunctions.associate(\"LATIN_TO_SORANI\", latinToSorani);\nCustomFunctions.associate(\"ADD\", add);\nCustomFunctions.associate(\"CLOCK\", clock);\nCustomFunctions.associate(\"INCREMENT\", increment);\nCustomFunctions.associate(\"LOG\", logMessage);"],"names":["soraniToLatinMap","ا","ە","ب","پ","ت","ج","چ","ح","خ","د","ر","ڕ","ز","ژ","س","ش","غ","ف","ڤ","ق","ک","گ","ل","ڵ","م","ن","ه","و","ۆ","ی","ێ","ع","ئ","وو","یە","یا","دە","نە","بە","لە","وا","کە","وە","تێ","پێ","بێ","بوو","latinToSoraniMap","Object","fromEntries","entries","map","sorani","latin","isConsonant","char","test","insertShortI","latinWord","vowels","consonants","result","i","length","includes","toLowerCase","prevChar","nextChar","substr","CustomFunctions","associate","text","sentences","split","sentence","trim","sentenceResult","words","word","j","matched","startsWith","len","Math","min","charAt","toUpperCase","slice","soraniWord","first","second","invocation","timer","setInterval","time","Date","toLocaleTimeString","setResult","onCanceled","clearInterval","incrementBy","message","console","log"],"sourceRoot":""}